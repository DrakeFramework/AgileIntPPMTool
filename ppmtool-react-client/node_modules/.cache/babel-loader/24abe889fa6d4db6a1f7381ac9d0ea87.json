{"ast":null,"code":"/**\r\n * library used to talk to the back end\r\n */\nimport axios from \"axios\";\n/**\r\n * import the types to be used\r\n */\n\nimport { GET_ERRORS, GET_PROJECTS, GET_PROJECT, DELETE_PROJECT } from \"./types\";\n/**\r\n * create var to hold the project es6 constant object def\r\n * async makes the dispatch asynchronous and when used with await it always returns a promise (js will wait until the promise is settled)\r\n *\r\n * returns a natural function\r\n */\n\nexport const createProject = (project, history) => async dispatch => {\n  // i will stick with his axios for now to learn new stuff but I think i still prefer jquery\n  // await $.postJSON(\n  //   \"/api/project\",\n  //   project,\n  //   function(data) {\n  //      history.push(\"/dashboard\");\n  //   },\n  //   function(xhr, textStatus, errorThrown) {\n  //      dispatch({\n  //        type: GET_ERRORS,\n  //        payload: JSON.parse(xhr.responseText)\n  //      });\n  //   }\n  // );\n  //this is the axios way of doing it\n  try {\n    //res is server response\n    //take the history parameter from the component and push the dashboard to see the new render\n    //await makes it a promise\n    //don't care about responseconst res =\n    await axios.post(\"/api/project\", project);\n    history.push(\"/dashboard\"); //when we have a good post without exception then just wipe out the errors\n\n    dispatch({\n      type: GET_ERRORS,\n      payload: {}\n    });\n  } catch (err) {\n    //if there is an error\n    //dispatch to GET_ERRORS reducer\n    //send with the response data to extract onto the form\n    dispatch({\n      type: GET_ERRORS,\n      payload: err.response.data\n    });\n  }\n};\n/**\r\n * basically the same as the post from above but with an axios \"get\" call which makes it much simpler\r\n * TODO research how parameters are passed in axios\r\n */\n\nexport const getProjects = () => async dispatch => {\n  const res = await axios.get(\"/api/project/all\");\n  dispatch({\n    type: GET_PROJECTS,\n    payload: res.data\n  });\n};\n/**\r\n * get a single fetch of project in the same pattern\r\n * this time take the id and history so we can control route on errors\r\n */\n\nexport const getProject = (id, history) => async dispatch => {\n  try {\n    //use backticks so we can map the id parameter onto the link\n    const res = await axios.get(\"/api/project/\".concat(id));\n    dispatch({\n      type: GET_PROJECT,\n      payload: res.data\n    });\n  } catch (err) {\n    history.push(\"/dashboard\");\n  }\n};\n/**\r\n * delete a project\r\n * because it's deleted from a list we can trust that it exists\r\n * because\r\n */\n\nexport const deleteProject = id => async dispatch => {\n  //add a confirmation to the delete\n  if (window.confirm(\"DELETE Seriously???\")) {\n    // removed because don't care about responseconst res =\n    await axios.delete(\"/api/project/\".concat(id));\n    dispatch({\n      type: DELETE_PROJECT,\n      //change this from res.data to id in order to use the filter in the reducer\n      // payload: res.data because it was changed from res to the id it just passes id to reducer\n      payload: id\n    });\n  }\n};","map":{"version":3,"sources":["C:/Users/dnelson/ideaProjects/PPMToolUdemyTutorial/ppmtool-react-client/src/actions/projectActions.js"],"names":["axios","GET_ERRORS","GET_PROJECTS","GET_PROJECT","DELETE_PROJECT","createProject","project","history","dispatch","post","push","type","payload","err","response","data","getProjects","res","get","getProject","id","deleteProject","window","confirm","delete"],"mappings":"AAAA;;;AAGA,OAAOA,KAAP,MAAkB,OAAlB;AACA;;;;AAGA,SAASC,UAAT,EAAqBC,YAArB,EAAmCC,WAAnC,EAAgDC,cAAhD,QAAsE,SAAtE;AAEA;;;;;;;AAMA,OAAO,MAAMC,aAAa,GAAG,CAACC,OAAD,EAAUC,OAAV,KAAsB,MAAMC,QAAN,IAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,MAAI;AACF;AACA;AACA;AACA;AACA,UAAMR,KAAK,CAACS,IAAN,CAAW,cAAX,EAA2BH,OAA3B,CAAN;AACAC,IAAAA,OAAO,CAACG,IAAR,CAAa,YAAb,EANE,CAOF;;AACAF,IAAAA,QAAQ,CAAC;AACPG,MAAAA,IAAI,EAAEV,UADC;AAEPW,MAAAA,OAAO,EAAE;AAFF,KAAD,CAAR;AAID,GAZD,CAYE,OAAOC,GAAP,EAAY;AACZ;AACA;AACA;AACAL,IAAAA,QAAQ,CAAC;AACPG,MAAAA,IAAI,EAAEV,UADC;AAEPW,MAAAA,OAAO,EAAEC,GAAG,CAACC,QAAJ,CAAaC;AAFf,KAAD,CAAR;AAID;AACF,CAtCM;AAwCP;;;;;AAIA,OAAO,MAAMC,WAAW,GAAG,MAAM,MAAMR,QAAN,IAAkB;AACjD,QAAMS,GAAG,GAAG,MAAMjB,KAAK,CAACkB,GAAN,CAAU,kBAAV,CAAlB;AACAV,EAAAA,QAAQ,CAAC;AACPG,IAAAA,IAAI,EAAET,YADC;AAEPU,IAAAA,OAAO,EAAEK,GAAG,CAACF;AAFN,GAAD,CAAR;AAID,CANM;AAQP;;;;;AAIA,OAAO,MAAMI,UAAU,GAAG,CAACC,EAAD,EAAKb,OAAL,KAAiB,MAAMC,QAAN,IAAkB;AAC3D,MAAI;AACF;AACA,UAAMS,GAAG,GAAG,MAAMjB,KAAK,CAACkB,GAAN,wBAA0BE,EAA1B,EAAlB;AACAZ,IAAAA,QAAQ,CAAC;AACPG,MAAAA,IAAI,EAAER,WADC;AAEPS,MAAAA,OAAO,EAAEK,GAAG,CAACF;AAFN,KAAD,CAAR;AAID,GAPD,CAOE,OAAOF,GAAP,EAAY;AACZN,IAAAA,OAAO,CAACG,IAAR,CAAa,YAAb;AACD;AACF,CAXM;AAaP;;;;;;AAKA,OAAO,MAAMW,aAAa,GAAGD,EAAE,IAAI,MAAMZ,QAAN,IAAkB;AACnD;AACA,MAAIc,MAAM,CAACC,OAAP,CAAe,qBAAf,CAAJ,EAA2C;AACzC;AACA,UAAMvB,KAAK,CAACwB,MAAN,wBAA6BJ,EAA7B,EAAN;AACAZ,IAAAA,QAAQ,CAAC;AACPG,MAAAA,IAAI,EAAEP,cADC;AAEP;AACA;AACAQ,MAAAA,OAAO,EAAEQ;AAJF,KAAD,CAAR;AAMD;AACF,CAZM","sourcesContent":["/**\r\n * library used to talk to the back end\r\n */\r\nimport axios from \"axios\";\r\n/**\r\n * import the types to be used\r\n */\r\nimport { GET_ERRORS, GET_PROJECTS, GET_PROJECT, DELETE_PROJECT } from \"./types\";\r\n\r\n/**\r\n * create var to hold the project es6 constant object def\r\n * async makes the dispatch asynchronous and when used with await it always returns a promise (js will wait until the promise is settled)\r\n *\r\n * returns a natural function\r\n */\r\nexport const createProject = (project, history) => async dispatch => {\r\n  // i will stick with his axios for now to learn new stuff but I think i still prefer jquery\r\n  // await $.postJSON(\r\n  //   \"/api/project\",\r\n  //   project,\r\n  //   function(data) {\r\n  //      history.push(\"/dashboard\");\r\n  //   },\r\n  //   function(xhr, textStatus, errorThrown) {\r\n  //      dispatch({\r\n  //        type: GET_ERRORS,\r\n  //        payload: JSON.parse(xhr.responseText)\r\n  //      });\r\n  //   }\r\n  // );\r\n\r\n  //this is the axios way of doing it\r\n  try {\r\n    //res is server response\r\n    //take the history parameter from the component and push the dashboard to see the new render\r\n    //await makes it a promise\r\n    //don't care about responseconst res =\r\n    await axios.post(\"/api/project\", project);\r\n    history.push(\"/dashboard\");\r\n    //when we have a good post without exception then just wipe out the errors\r\n    dispatch({\r\n      type: GET_ERRORS,\r\n      payload: {}\r\n    });\r\n  } catch (err) {\r\n    //if there is an error\r\n    //dispatch to GET_ERRORS reducer\r\n    //send with the response data to extract onto the form\r\n    dispatch({\r\n      type: GET_ERRORS,\r\n      payload: err.response.data\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * basically the same as the post from above but with an axios \"get\" call which makes it much simpler\r\n * TODO research how parameters are passed in axios\r\n */\r\nexport const getProjects = () => async dispatch => {\r\n  const res = await axios.get(\"/api/project/all\");\r\n  dispatch({\r\n    type: GET_PROJECTS,\r\n    payload: res.data\r\n  });\r\n};\r\n\r\n/**\r\n * get a single fetch of project in the same pattern\r\n * this time take the id and history so we can control route on errors\r\n */\r\nexport const getProject = (id, history) => async dispatch => {\r\n  try {\r\n    //use backticks so we can map the id parameter onto the link\r\n    const res = await axios.get(`/api/project/${id}`);\r\n    dispatch({\r\n      type: GET_PROJECT,\r\n      payload: res.data\r\n    });\r\n  } catch (err) {\r\n    history.push(\"/dashboard\");\r\n  }\r\n};\r\n\r\n/**\r\n * delete a project\r\n * because it's deleted from a list we can trust that it exists\r\n * because\r\n */\r\nexport const deleteProject = id => async dispatch => {\r\n  //add a confirmation to the delete\r\n  if (window.confirm(\"DELETE Seriously???\")) {\r\n    // removed because don't care about responseconst res =\r\n    await axios.delete(`/api/project/${id}`);\r\n    dispatch({\r\n      type: DELETE_PROJECT,\r\n      //change this from res.data to id in order to use the filter in the reducer\r\n      // payload: res.data because it was changed from res to the id it just passes id to reducer\r\n      payload: id\r\n    });\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}